<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Visualizer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }
        canvas {
            border: 1px solid black;
            background-color: #f9f9f9;
        }
        .controls {
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h2>Neural Network Visualizer</h2>
    <canvas id="networkCanvas" width="600" height="400"></canvas>
    <div class="controls">
        <button onclick="forwardPropagation()">Run Forward Propagation</button>
    </div>

    <script>
        const canvas = document.getElementById('networkCanvas');
        const ctx = canvas.getContext('2d');

        // Neural Network structure
        const layers = [
            { neurons: 3 },  // Input layer
            { neurons: 4 },  // Hidden layer 1
            { neurons: 4 },  // Hidden layer 2
            { neurons: 2 }   // Output layer
        ];

        const positions = []; // Store neuron positions for drawing connections

        // Draw the initial neural network
        function drawNetwork() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            positions.length = 0;

            layers.forEach((layer, layerIndex) => {
                const numNeurons = layer.neurons;
                const ySpacing = canvas.height / (numNeurons + 1);
                const x = (layerIndex + 1) * (canvas.width / (layers.length + 1));
                const layerPositions = [];

                for (let i = 0; i < numNeurons; i++) {
                    const y = (i + 1) * ySpacing;
                    drawNeuron(x, y);
                    layerPositions.push({ x, y });
                }

                positions.push(layerPositions);
            });

            // Draw connections between layers
            for (let i = 0; i < positions.length - 1; i++) {
                const currentLayer = positions[i];
                const nextLayer = positions[i + 1];

                currentLayer.forEach(neuronA => {
                    nextLayer.forEach(neuronB => {
                        drawConnection(neuronA, neuronB);
                    });
                });
            }
        }

        // Draw a neuron (circle)
        function drawNeuron(x, y) {
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, 2 * Math.PI);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.stroke();
        }

        // Draw a connection (line)
        function drawConnection(start, end) {
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.strokeStyle = '#aaa';
            ctx.stroke();
        }

        // Simulate forward propagation
        function forwardPropagation() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawNetwork();

            // Highlight forward propagation
            for (let i = 0; i < positions.length - 1; i++) {
                const currentLayer = positions[i];
                const nextLayer = positions[i + 1];

                currentLayer.forEach(neuronA => {
                    nextLayer.forEach(neuronB => {
                        // Draw active connection in a different color
                        ctx.beginPath();
                        ctx.moveTo(neuronA.x, neuronA.y);
                        ctx.lineTo(neuronB.x, neuronB.y);
                        ctx.strokeStyle = '#00f'; // Blue for active connection
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    });
                });
            }
        }

        drawNetwork();
    </script>
</body>
</html>
